# Tomasulo Simulator Report

* 计72 邹振华 2017011464



## 一 实验环境

Win10 pro x64 cmd

gcc version 8.1.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project)

VS Code 1.43.2

GNU Make 4.2.1



## 二 设计思路

首先我维护了一个list (window) 用于记录当前正在活跃的指令，也就是已经发射，但是还没有完成写回的指令list，该list本身就是按照指令发射顺序进行排列的

我实现了 TMSLSimulator 类用于模拟 Tomasulo 算法的执行流程：

* 首先从文件中读入所有指令，解析出命令类型，操作数（包含即时数和寄存器），存放到lines数组中。

* 然后执行最为关键的函数是doClocks()，该函数定义了每个时钟周期内模拟器需要执行的操作，包含：
  * 广播写回数据，回收保留站、取缓冲、FU等功能部件
    * 主要功能函数 `doCollect()`
  * 试图发射新的指令，占用保留站
    * 主要功能函数 `doLaunchLines()`
  * 现有window中的指令(已经进入保留站的，包含本周期刚发射的)抢占功能部件队列
    * 将操作数已经准备好的window中的指令加入对应FU的队列中(同一周期内就绪的指令按照发射顺序进入队列) 
    * 主要功能函数 `grabFU()`
  * 填充FU：遍历FU，如果有空闲的而且对应队列不为空的话，取出保留站占用FU
    * 主要功能函数 `dequeFU()`
  * 功能部件进行执行

    * 但是不包含本周期就绪的指令（实际的实现为在指令就绪的时候把剩余周期 + 1）
    * 执行结束以后如果剩余的时间为0，那么执行实际的计算操作，存入FU的result中，等待下一个周期开始进行广播写回，并回收FU
    * 主要功能函数 `doFU()`

`doclocks()`函数本身已经保证了先就绪的指令优先占用FU

为了在广播写回结果的时候提高执行效率，我给每个保留站维护了一个待写回的保留站队列和待写回的寄存器队列，该保留站的FU广播写回结果的时候，会遍历这两个队列进行写回。为了避免WAW冲突，寄存器写回的时候会判断该寄存器是否还在等待本保留站

#### 扩展 实现Jump指令

Jump指令的添加其实并不困难，主要就是设置标记，当有一条Jump指令发射以后，我设置hasJump为真，该标记为真的时候往后的指令不可以发射

在Jump执行完计算的周期的下一个周期的开始（doCollect函数内），判断是否能成功跳转，如果能成功跳转的话将下一条待发射的指令进行相应的调整，然后将hasJump设置为假，使得该周期内可以正常发射目标指令；如果不能成功跳转的话仅仅将hasJump设置为假，继续发射执行Jump指令后面的指令



## 三 Tomasulo算法的特点分析

我认为Tomasulo的核心在于使用保留站进行寄存器换名，将指令各个阶段的执行控制转移给了保留站和功能部件，并且使用数据总线广播计算结果进行写回。

寄存器换名使得每个保留站等待的刚好是往前看（时间上往前）的最近一条写了源操作数的指令所在的保留站，并不依赖于寄存器，因此并不用担心在等待依赖关系建立后该寄存器被后面的指令覆盖写，也就是解决了读后写相关，而等待依赖关系对应的正好是写后读相关。至于写寄存器，可以注意到Tomasulo算法中寄存器的依赖Qi在指令发射阶段被确定，因此寄存器依赖的Qi始终是最后一条被发射的要写它的指令所在的保留站，不必担心后发射的指令写了寄存器又被前面发射的指令写，这解决了写后写相关。

将指令执行控制转移给保留站、存取缓冲和FU降低提高了执行效率，降低了单个模块的控制负担。尤其使用数据总线广播计算结果，只要数据总线带宽足够，可以在一个周期内完成对所有目标保留站和寄存器的写，回收保留站、寄存器、FU资源，紧接着进行下一轮的指令发射和就绪。

当然Tomasulo算法的分布式控制也就意味着实现的复杂性，在实验中发现Tomasulo算法实现所需要关注的细节很多，而且由于需要维护的变量也很多，很容易出错。仅仅软件模拟就如此复杂，硬件实现肯定也很不容易。



## 四 Tomasulo算法和记分牌算法的对比

Tomasulo算法和记分牌算法的根本区别有两点，首先Tomasulo采用分布式指令执行控制，记分牌算法采用集中式指令执行控制，完全依赖记分牌中记录的信息来控制指令的执行；其次记分牌依靠本身的寄存器换名机制解决了写后写、写后读、读后写相关，实际上算是消除了写后写和读后写相关（只要保留站的数量足够多），但是记分牌算法只能根据记分牌的记录采取一些判断来限制执行的执行。如果观察得比较表面的话，可以对比指令执行不同阶段两种算法的区别：

|                  | Tomasulo               | 记分牌                                             |
| ---------------- | ---------------------- | -------------------------------------------------- |
| 流出             | 对应保留站空闲即可流出 | 需要FU空闲并且目标寄存器没有等待(结构阻塞，写后写) |
| 读取操作数，执行 | 操作数准备好，FU空闲   | 操作数准备好                                       |
| 写回             | 数据总线广播结果       | 目标寄存器已经被读（读后写）                       |

可以看到对于指令相关，记分牌算法倾向于避免，也就是检测到冲突让指令直接暂停在某个阶段，但是Tomasulo算法通过寄存器换名和FU队列来解决指令相关和结构阻塞，因此Tomasulo算法中的指令更容易流出，也就能够能够获得更高的执行效率

要设计对比两个算法的指令序列其实很简单，就比如以下的LD指令序列：

```
1:LD,R0,0x2
2:LD,R0,0x2
3:LD,R0,0x2
4:LD,R0,0x2
5:LD,R0,0x2
6:LD,R0,0x2
7:LD,R0,0x2
```

假设两种算法中都有两个LD的FU，Tomasulo算法有3个取缓冲，LD执行需要三个周期（也就是同本次实验），下面对两种算法执行进行分析：(括号中的数字代表就绪指令执行的剩余周期)

| Cycle | Tomasulo          | 记分牌      |
| ----- | ----------------- | ----------- |
| 1     | 1发射，1(3)       | 1发射，1(3) |
| 2     | 2发射，1(2)，2(3) | 1(2)        |
| 3     | 3发射，1(1)，2(2) | 1(1)        |
| 4     | 1(0)，2(1)        | 1(0)        |
| 5     | 4发射，3(3)，2(0) | 2发射，2(3) |
| 6     | 5发射，4(3)，3(2) | 2(2)        |
| 7     | 4(2)，3(1)        | 2(1)        |
| 8     | 4(1)，3(0)        | 2(0)        |
| 9     | 6发射，5(3)，4(0) | 3发射，3(3) |
| 10    | 6(3)，5(2)        | 3(2)        |
| 11    | 6(2)，5(1)        | 3(1)        |
| 12    | 6(1)，5(0)        | 3(0)        |
| 13    | 6(0)              | 4发射，4(3) |
| 14    |                   | 4(2)        |
| 15    |                   | 4(1)        |
| 16    |                   | 4(0)        |
| 17    |                   | 5发射，5(3) |
| 18    |                   | 5(2)        |
| 19    |                   | 5(1)        |

可见对于上述指令序列相同FU数量Tomasulo算法的执行效率高很多，因为每条指令的目标寄存器相同，所以记分牌算法的指令发射就一直被阻塞了。



## 五 运行结果

* *.basic.nel 文件的执行结果见log
* Mul.nel:
  * <img src="C:\Users\HarryM\AppData\Roaming\Typora\typora-user-images\image-20200518164037301.png" alt="image-20200518164037301" style="zoom: 67%;" />

* Big_test.nel
  * <img src="C:\Users\HarryM\AppData\Roaming\Typora\typora-user-images\image-20200518164139176.png" alt="image-20200518164139176" style="zoom:67%;" />



## 六 实验总结

本次实验中首先的困难是对算法的学习，虽然课上有认真听，但是由于没有自己手推过，所以对记分牌算法和Tomasulo算法的具体执行还是模糊的。读教材的时候第一遍是直接读Tomasulo算法的介绍，感觉云里雾里，过了两天重头来读，从记分牌算法读起，理解了记分牌算法后，对Tomasulo算法的很多操作为什么要这么做有了更清晰的认识。结合Example例子的学习，对Tomasulo算法每个周期中执行的操作有了更为清晰的认识，比如进入就绪状态（抓取到FU）和开始执行并不在一个周期，执行结束和写回也不在一个周期，但是广播写回结果和监听保留站进入就绪状态却在一个周期，清晰掌握这些细节对我正确实现Tomasulo算法的帮助很大

还有就是执行效率的提升，刚开始我的广播写回采用的是暴力遍历所有的保留站、寄存器，看是否有人需要当前FU的计算结果，本来以为保留站和寄存器的数目不多，应该对时间效率影响不大，但事实是程序真的很慢。后来我在每个保留站设置了一个等待该保留站中指令执行结果的保留站队列(Q_RS)和寄存器队列(Q_R)，指令广播的时候只对这些保留站和寄存器进行通知，程序时间效率提升了很多